
#include "FS.h"
#include "SD.h"
#include "SPI.h"
//these are defined in FluidNC config for the MKS DLC board
const int misoPin = 12;
const int mosiPin = 13;
const int sckPin = 14;
const int csPin = 15;
unsigned long startTime = millis(); //in ms
String stringLogFileName = "/log" + getFormatedTimeSinceStart() + ".txt";

const char *fileName = stringLogFileName.c_str(); //todo in one line

// XXX This should be a configuration parameter of the SPI bus
const int32_t SPIfreq = 4000000;
unsigned long zeroTimeMillis = 0; //in ms
void createDir(fs::FS &fs, const char *path) {
	Serial.printf("Creating Dir: %s\n", path);
	if (fs.mkdir(path)) {
		Serial.println("Dir created");
	} else {
		Serial.println("mkdir failed");
	}
}
void listDir(fs::FS &fs, const char *dirname, uint8_t levels) {
	Serial.printf("Listing directory: %s\n", dirname);
	File root = fs.open(dirname);
	if (!root) {
		Serial.println("Failed to open directory");
		return;
	}
	if (!root.isDirectory()) {
		Serial.println("Not a directory");
		return;
	}
	File file = root.openNextFile();
	while (file) {
		if (file.isDirectory()) {
			Serial.print("  DIR : ");
			Serial.println(file.name());
			if (levels) {
				listDir(fs, file.name(), levels - 1);
			}
		} else {
			Serial.print("  FILE: ");
			Serial.print(file.name());
			Serial.print("  SIZE: ");
			Serial.println(file.size());
		}
		file = root.openNextFile();
	}
}
void removeDir(fs::FS &fs, const char *path) {
	Serial.printf("Removing Dir: %s\n", path);
	if (fs.rmdir(path)) {
		Serial.println("Dir removed");
	} else {
		Serial.println("rmdir failed");
	}
}
void readFile(fs::FS &fs, const char *path) {
	Serial.printf("Reading file: %s\n", path);

	File file = fs.open(path);
	if (!file) {
		Serial.println("Failed to open file for reading");
		return;
	}

	Serial.print("Read from file: ");
	while (file.available()) {
		Serial.write(file.read());
	}
	file.close();
}
void writeFile(fs::FS &fs, const char *path, const char *message) {
	Serial.printf("Writing file: %s\n", path);
	File file = fs.open(path, FILE_WRITE);
	if (!file) {
		Serial.println("Failed to open file for writing");
		return;
	}
	if (file.print(message)) {
		Serial.println("File written");
	} else {
		Serial.println("Write failed");
	}
	file.close();
}
void appendFile(fs::FS &fs, const char *path, const char *message) {
	Serial.printf("Appending to file: %s\n", path);
	File file = fs.open(path, FILE_APPEND);
	if (!file) {
		Serial.println("Failed to open file for appending");
		return;
	}
	if (file.print(message)) {
		Serial.println("Message appended");
	} else {
		Serial.println("Append failed");
	}
	file.close();
}
void renameFile(fs::FS &fs, const char *path1, const char *path2) {
	Serial.printf("Renaming file %s to %s\n", path1, path2);
	if (fs.rename(path1, path2)) {
		Serial.println("File renamed");
	} else {
		Serial.println("Rename failed");
	}
}
void deleteFile(fs::FS &fs, const char *path) {
	Serial.printf("Deleting file: %s\n", path);
	if (fs.remove(path)) {
		Serial.println("File deleted");
	} else {
		Serial.println("Delete failed");
	}
}
void testFileIO(fs::FS &fs, const char *path) {
	File file = fs.open(path);
	static uint8_t buf[512];
	size_t len = 0;
	uint32_t start = millis();
	uint32_t end = start;
	if (file) {
		len = file.size();
		size_t flen = len;
		start = millis();
		while (len) {
			size_t toRead = len;
			if (toRead > 512) {
				toRead = 512;
			}
			file.read(buf, toRead);
			len -= toRead;
		}
		end = millis() - start;
		Serial.printf("%u bytes read for %u ms\n", flen, end);
		file.close();
	} else {
		Serial.println("Failed to open file for reading");
	}
	file = fs.open(path, FILE_WRITE);
	if (!file) {
		Serial.println("Failed to open file for writing");
		return;
	}
	size_t i;
	start = millis();
	for (i = 0; i < 2048; i++) {
		file.write(buf, 512);
	}
	end = millis() - start;
	Serial.printf("%u bytes written for %u ms\n", 2048 * 512, end);
	file.close();
}
void setup() {
	Serial.begin(115200);
	//SPI.begin(sckPin, misoPin, mosiPin);  // CS is defined by each device
	SPIClass hspi = SPIClass(HSPI); //HSPI has the 12-15 pins already configured // actually a reference
	if (!SD.begin(csPin, hspi, SPIfreq, "/sd", 2)) { //copied from Fluid SDCard.cpp //if (SD.begin(csPin, SPI, SPIfreq, "/sd", 2)) {
		//if(!SD.begin(csPin)){  //copied from Fluid SDCard.cpp //if (SD.begin(csPin, SPI, SPIfreq, "/sd", 2)) {
		Serial.println("Card Mount Failed");
		return;
	}
	uint8_t cardType = SD.cardType();
	if (cardType == CARD_NONE) {
		Serial.println("No SD card attached");
		return;
	}
	Serial.print("SD Card Type: ");
	if (cardType == CARD_MMC) {
		Serial.println("MMC");
	} else if (cardType == CARD_SD) {
		Serial.println("SDSC");
	} else if (cardType == CARD_SDHC) {
		Serial.println("SDHC");
	} else {
		Serial.println("UNKNOWN");
	}
	uint64_t cardSize = SD.cardSize() / (1024 * 1024);
	Serial.printf("SD Card Size: %lluMB\n", cardSize);
	listDir(SD, "/", 0);
//	createDir(SD, "/adriandir");
//	listDir(SD, "/", 0);
//	removeDir(SD, "/mydir");
//	listDir(SD, "/", 2);
//	writeFile(SD, "/hello.txt", "Hello ");
//	appendFile(SD, "/hello.txt", "World!\n");
//	readFile(SD, "/hello.txt");
//	deleteFile(SD, "/foo.txt");
//	renameFile(SD, "/hello.txt", "/foo.txt");
//	readFile(SD, "/foo.txt");
//	testFileIO(SD, "/test.txt");
//	Serial.printf("Total space: %lluMB\n", SD.totalBytes() / (1024 * 1024));
//	Serial.printf("Used space: %lluMB\n", SD.usedBytes() / (1024 * 1024));
	//time stuff
	Serial.println(" Starting a log named: " + String(fileName));
	writeOnce();
	appendFile(SD, fileName, "World!\n");
	for (int i = 0; i < 2; i++) {
		appendToIt();
		delay(2000);
	}
	Serial.println("Finished Logging");
}

boolean firstTime = true;

void loop() {
	if (firstTime) {
		Serial.println(" try print in loop first time ");
		firstTime = false;
		listDir(SD, "/", 0);
		writeOnce();
		//appendToIt();
		delay(3000);
	} else {
		while (true)
			;
	}
}

void writeOnce() {
	Serial.println(" in writeOnce");
	File myFile = SD.open(fileName, FILE_WRITE); // create or open a file for writing
	Serial.println(" after: " + getFormatedTimeSinceStart());
	if (myFile) {
		myFile.println(millis() - zeroTimeMillis); //last item of the CSV entry is the current time, saving this with a carriage return to terminate CSV row
		Serial.println(" after: " + getFormatedTimeSinceStart());
		delay(1000); //wait around 1 second and then do it all again!
		myFile.close(); //close the SD card file
		delay(1000);
	} else //if the SD card DOES NOT WRITE, then
	{
		Serial.println("the SD card DOES NOT WRITE");
	}
	delay(2000);
}

void appendToIt() {
	Serial.println(" in appendToIt");
	File myFile = SD.open(fileName, FILE_APPEND); // create or open a file for writing
	Serial.println(" after: " + getFormatedTimeSinceStart());
	//appendFile(SD, fileName, "World!\n");
	if (myFile) {
		myFile.println(millis() - zeroTimeMillis); //last item of the CSV entry is the current time, saving this with a carriage return to terminate CSV row
		Serial.println(" after: " + getFormatedTimeSinceStart());
		delay(1000); //wait around 1 second and then do it all again!
		myFile.close(); //close the SD card file
		delay(1000);
	} else //if the SD card DOES NOT WRITE, then
	{
		Serial.println("the SD card DOES NOT WRITE");
	}
	delay(2000);
}

String getFormatedTimeSinceStart() {
	unsigned long time = (unsigned long) ((millis() - startTime) / 1000); //finds the time since last print in secs
	return formatTime(time);
}

String formatTime(unsigned long time) {
	String result = "";
	int hours = (unsigned long) (time / 3600);
	if (hours > 0) {
		result = +hours;
		result += ("h ");
	}
	result += ((unsigned long) (time % 3600) / 60);
	result += ("m ");
	result += (time % 60);
	result += ("s");
	return result;
}
